# Conflict Event Sequences (Africa)

This repository introduces **four approaches to cluster conflict events with the goal of building conflict event sequences**. For each approach a class was defined, allowing to build sequences over time with different indicees and metrices. Additionally each class includes plotting and summary options to describe the sequences. 

Further more, there are options to compare different seuqneces using the compare sequence cluster class. 

Going further than build a sequence this repro also give an idea of how groups of sequences with similar conflict development patterns can be created. In preparation different normalization opperations are offered. In that way, the sequences development can be represented by a vector with a fixed dimension. This is crucial to build a cluster over sequences.

This repository is a collaborative work by Luke-Liam Bergmeier and Sarah Deubner.

# Final Results
Refer to the notebook `notebooks/final_sequence_clustering` to get an overview of all four sequence types their comparison, nomalization and clustering.
# Dataset

The analysis of conflict data in Africa is based on two datasets, which are aggregated:
the Armed Conflict Location and Event Data Project (ACLED) and the Uppsala Conflict
Data Program (UCDP). Both are event-based datasets, meaning that the unit of
observation is an individual incident of political violence or disorder. Each event specifies the actors involved, the type of incident, the time and place of occurrence, as well as additional details such as fatalities and a note.

The `data_loder.py` functions load and prepare the data. The data should be stored under `data/raw_data`. A data exploration analysis can be found under `notebooks/EDA`.

# Build Sequences
For all seuqneces two thresholds are set:
- Minimum Number of Fatalities (per year): 25
- Minimum Number of Sequence Events (total): 10
## 1. Actor-based Conflict Event Sequences 
`class DYAD_YEAR_SEQ_CLUSTER`
An Actor-based Conflict Event Sequences defines one unit as all events related to one
dyad. (A dyad refers to a pair of distinct actors engaged in the same conflict, irrespective of their type.)
## 2. Network Actor-based Conflict Event Sequences
`class COMBINED_DYAD_YEAR_SEQ_CLUSTER`
An extention of Actor-based Conflict Event Sequences, where sequences are combined in one larger sequences if all of these rules apply:
1. Dyad overlap – their respective sequences have an overlap in their dyad attributes, meaning they have the same actor
2. Temporal overlap – the active periods of the two sequences must overlap by at least a defined fraction (≥ 70% in our case).
3. Geographic proximity – the mean event locations of the two sequences must be within a maximum distance threshold (200 km).

A network is used to build these connections between sequences. A connected subnetwork of Actor-based Conflict Event Sequences then builds a new Network Actor-based Conflict Event Sequence.
## 3. Spatio-Temporal-based Conflict Event Sequences
`class HDBSCAN_SEQ_CLUSTER`
Usues HDBScan to cluster events dense in time and space to one sequence.
## 4. Spatio-Temporal- and Semantic-Based Conflict Event Sequences
`class EMBEDDING_SEQ_CLUSTER`
An extention of Spatio-Temporal-based Conflict Event Sequences, where additional information of each event is represented by a low dimensional embedding space. This embedding space in combination with the events location and time builds the feature space over which HDBScan searches for dense regions.

The notebook `notebooks/build_sequences` shows how to deal with the classes.

# Compare
`class CLUSTER_SEQ_COMPARISON`
This module allows you to compare sequences of conflict events generated by different clustering methods. By mapping events to sequences, it computes similarity metrics (e.g., Adjusted Rand Index, Normalized Mutual Information, Fowlkes-Mallows Index) between clusterings to quantify how consistent they are. It also analyzes sequence overlaps, visualizes sequence size distributions, and highlights differences in event coverage across methods.

# Normalization
The main normalization option is a **binned intergal approach** (temporal_curve_integral). Compare temporal dynamics across sequences with different durations by dividing each
sequence into B fixed bins. The integral captures development within a bin: Steady build-up, Sudden spikes, Late surges.

You can finde the nomalization options under `utils/normalization.py`. To use the normalization function a normalization_config has to be set up, here is an example:<pre> 
normalization_config = {
    'fatalities': 'proportional',
    'event_id_cnty': 'proportional', 
    'time': 'relative_steps',
    'temporal_curve': 'fatality_curve',
    'temporal_curve_integral': 'integral',
    'n_bins': 20,
    'binning_method': 'temporal',
    'curve_type': 'cumulative',
}</pre>

# Clustering
So far we tried KMeans-Clustering for binned intergral fatalitiy curves and **...**. The build cluster can be viewed in the notebook `notebooks/final_sequence_clustering`. The `clustering.py`functions give different cluster, plotting and summary options (framed for the sequences classes).

# Set up

Before starting, ensure you have Python 3.10+, pip, and pipenv installed.

1. Clone the Repository
Download the repository to your local machine.

2. Install Dependencies
You can choose between two installation modes:

- Development Installation: Installs core dependencies and tools for development, testing, and documentation pipenv install --dev
- Standard Installation: Installs only the core dependencies to run the project pipenv install

3. Activate the Environment
Activate the virtual environment after installing dependencies.

4. Set PYTHONPATH
Ensure that PYTHONPATH is set to the root directory of the project for proper module resolution.

Once these steps are complete, your environment will be ready to use.



